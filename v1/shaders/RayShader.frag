#version 450#extension GL_ARB_separate_shader_objects : enable// Questo definisce la variabile ricevuta dal Vertex Shader// le posizioni devono corrispondere a quelle delle sue variabili outlayout(location = 0) in vec2 fragUV;// Questo definisce il colore calcolato da questo shader. Generalmente è sempre location 0.layout(location = 0) out vec4 outColor;layout(set = 0, binding = 0) uniform GlobalUniformBufferObject {    vec3 lightPos;    vec4 lightColor;    vec3 eyePos;} gubo;layout(set = 1, binding = 0) uniform UniformBufferObject {    vec3 cameraPos; // Posizione della camera    mat4 invViewMatrix; // Matrice di vista inversa    mat4 invProjectionMatrix; // Matrice di proiezione inversa} ubo;struct Ray {    vec3 origin;    vec3 direction;};struct Sphere {    vec3 center;    float radius;	vec4 color;};// Funzione per calcolare l'intersezione tra un raggio e una sferabool intersectSphere(Ray ray, Sphere sphere, out vec3 intersectionPoint) {    vec3 oc = ray.origin - sphere.center; // distanza tra i due centri	    // coefficienti della formula quadratica per l'intersezione di un raggio con una sfera    float a = dot(ray.direction, ray.direction); // a = 1    float b = 2.0 * dot(oc, ray.direction);    float c = dot(oc, oc) - sphere.radius * sphere.radius;    float discriminant = b * b - 4.0 * a * c;    if (discriminant > 0.0) {        // poiché è un'equazione quadratica abbiamo due possibili soluzioni, quindi dobbiamo prendere la più vicina        float dst = (-b - sqrt(discriminant)) / (2.0 * a);        if (dst > 0.0) {            intersectionPoint = ray.origin + dst * ray.direction;            return true;        }    }    return false;}// Funzione per definire le sfereSphere getSphere(int index) {    if (index == 0) return Sphere(vec3(0.0, 0.0, 5.0), 1.0, vec4(1.0f, 0.0f, 0.0f, 1.0f));    else if (index == 1) return Sphere(vec3(2.0, 1.0, 6.0), 1.5, vec4(0.0f, 0.0f, 1.0f, 1.0f));    else return Sphere(vec3(-2.0, -1.0, 7.0), 1.0, vec4(1.0f, 0.0f, 1.0f, 1.0f));}void main() {    vec2 ndc = fragUV * 2.0 - 1.0; // Convertiamo le coordinate UV in coordinate NDC (Normalized Device Coordinates), passiamo da un sistema [0,1] a [-1,1]    vec4 clipCoords = vec4(ndc, -1.0, 1.0); // Creiamo un punto nello spazio partendo dalle coordinate di prima, con z = -1    // Convertiamo le coordinate della clip in coordinate dello spazio della vista    vec4 viewCoords = ubo.invProjectionMatrix * clipCoords;    // Normalizziamo le coordinate    vec3 rayDirection = normalize(viewCoords.xyz);    // Trasformiamo la direzione del raggio nello spazio del mondo    rayDirection = normalize(vec3(ubo.invViewMatrix * vec4(rayDirection, 0.0)));    // Creiamo il raggio    Ray ray;    ray.origin = ubo.cameraPos;    ray.direction = rayDirection;	    // Punto di intersezione    vec3 intersectionPoint;	vec4 hitColor = vec4(0.0f); // colore default nero	float closestDst = 1000.0; 		for(int i = 0; i < 3; i++){		Sphere s = getSphere(i);				if(intersectSphere(ray, s, intersectionPoint)){			float dst = length(intersectionPoint - ray.origin);			if(dst < closestDst){				closestDst = dst;                hitColor = s.color;			}		}	}		outColor = hitColor;}