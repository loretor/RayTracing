#version 450#extension GL_ARB_separate_shader_objects : enable#define SPHERE 0#define PLANE 1#define MAX_DEPTH 3#define N_OBJECTS 4const float NON_DIELECTRIC_REFRACTIVE_INDEX = 1e-6; //indice di rifrazione da associare a elementi non dielettrici, di modo tale che il metodo di isTotalRiflession() ? sia sempre True per loro// Questo definisce la variabile ricevuta dal Vertex Shader// le posizioni devono corrispondere a quelle delle sue variabili outlayout(location = 0) in vec2 fragUV;// Questo definisce il colore calcolato da questo shader. Generalmente è sempre location 0.layout(location = 0) out vec4 outColor;layout(set = 0, binding = 0) uniform GlobalUniformBufferObject {	int numberOfSamples;	int width;	int height;} gubo;	layout(set = 0, binding = 1) uniform sampler2D tex;layout(set = 1, binding = 0) uniform UniformBufferObject {    vec3 cameraPos; // Posizione della camera    mat4 invViewMatrix; // Matrice di vista inversa    mat4 invProjectionMatrix; // Matrice di proiezione inversa} ubo;struct Ray {    vec3 origin;    vec3 direction;};/* struct per i materiali    - color: colore associato all'oggetto	- emissionColor: se è una luce = bianco, altrimenti = nero (nel caso di luce metti color = nero)	- emissionStrength: potenza associata alla luce [0,1]	- smoothness: indice per gli specchi, più vicino a 0 più sarà un diffuse material, più vicino a 1 e più sarà uno specchio [0,1] 	- dieletricConstant: indice per i materiali dieletrici, se = 0 allora il materiale non è dieletrico, se > 1 allora questo è il suo indice 	Esempi di materiali	- SPECCHIO: colore = bianco, smoothness > 0.0 (= 1.0 specchio perfettamente riflettente)	- NON SPECCHIO: smoothness = 0.0	- DIELETTRICO: dieletricConstant > 1.0, smoothness > 0.0 (perchè questo valore serve per decidere se il raggio incidente viene riflesso o rifratto)	- NON DIELETTRICO: dieletricConstant < 1.0	- DIFFUSE: colore = qualsiasi, emissionStrength = 0.0, emissionColor = nero	- LUCE: colore = qualisasi, emissionStrength > 0.0, emissionColor != nero*/struct RayTracingMaterial{	vec4 color; 	vec4 emissionColor; 	float emissionStrength; 	float smoothness; 	float dieletricConstant;};struct GeometryHit{ // questa struttura dati contiene le informazioni dell'oggetto che abbiamo colpito col raggio	bool isHit;	vec3 position;	vec3 normal;	RayTracingMaterial material;	int index; //questo serve per sapere che indice ha la geometry nell'array di geometry (serve ad esempio nella refraction)};// Rendiamo più generico, aggiungiamo la possibilità di inserire nuove figure geometrichestruct Geometry {	//caratteristiche comuni a tutti    int type;	RayTracingMaterial material;	    vec3 center;   // Solo per sfere    float radius;  // Solo per sfere    vec3 point;    // Solo per piani    vec3 normal;   // Solo per piani};// -------------------------- PCG -----------------------------uint randomState;// PCG (permuted congruential generator) www.pcg-random.org uint NextRandom(inout uint state) {	state = state * 747796405 + 2891336453;	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;	result = (result >> 22) ^ result;	return result;}float RandomValue(inout uint state) {	return NextRandom(state) / 4294967295.0; // 2^32 - 1}// Random value in normal distribution (with mean=0 and sd=1) https://stackoverflow.com/a/6178290float RandomValueNormalDistribution(inout uint state) {	float theta = 2 * 3.1415926 * RandomValue(state);	float rho = sqrt(-2 * log(RandomValue(state)));	return rho * cos(theta);}vec3 RandomDirection(inout uint state) {	float x = RandomValueNormalDistribution(state);	float y = RandomValueNormalDistribution(state);	float z = RandomValueNormalDistribution(state);	return normalize(vec3(x, y, z));}// Genera un punto casuale sul cerchio di raggio 1, usato per il jitteringvec2 RandomPointInCircle(inout uint rngState){	float angle = RandomValue(rngState) * 2 * 3.1415926; //otteniamo un angolo randomico della sfera	vec2 pointOnCircle = vec2(cos(angle), sin(angle)); //trasformiamo l'angolo in coordinate 2D	return pointOnCircle * sqrt(RandomValue(rngState)); //otteniamo un punto qualsiasi lungo il raggio che collega il centro al punto 2D}// ------------------- RAY INTERSECTION METHODS --------------------- Geometry geometries[N_OBJECTS];// Funzione per calcolare l'intersezione tra un raggio e una sferabool intersectSphere(Ray ray, Geometry geom, out GeometryHit hit) {    vec3 oc = ray.origin - geom.center; // distanza tra i due centri	    // coefficienti della formula quadratica per l'intersezione di un raggio con una sfera    float a = dot(ray.direction, ray.direction); // a = 1    float b = 2.0 * dot(oc, ray.direction);    float c = dot(oc, oc) - geom.radius * geom.radius;    float discriminant = b * b - 4.0 * a * c;    if (discriminant > 0.0) {		float t0 = (-b - sqrt(discriminant)) / (2.0 * a);        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);				float dst = -1.0; // prendi sempre la più piccola positiva        if (t0 > 0.0) {            dst = t0;        }        if (t1 > 0.0 && (dst < 0.0 || t1 < dst)) {            dst = t1;        }                if (dst > 0.0) {            hit.position = ray.origin + dst * ray.direction;			hit.normal = normalize(hit.position - geom.center);			hit.material = geom.material;			hit.isHit = true;            return true;        }    }    return false;}bool intersectPlane(Ray ray, Geometry geom, out GeometryHit hit) {    float denom = dot(geom.normal, ray.direction);     if (abs(denom) < 0.0001f) { //verifichiamo che il raggio non sia parallelo al piano        return false;     }    vec3 rayPlane = geom.point - ray.origin; // Vettore dal punto del raggio al punto del piano    float t = dot(rayPlane, geom.normal) / denom; // distanza      if (t < 0) { // Se t è negativo, l'intersezione è dietro il raggio        return false;     }    hit.position = ray.origin + t * ray.direction; 	hit.normal = geom.normal;	hit.material = geom.material;	hit.isHit = true;    return true;}// Scegliamo il metodo di calcolo dell'intersezione sulla base della tipologia di geometriabool intersectGeometry(Ray ray, Geometry geom, inout GeometryHit hit) {    if (geom.type == SPHERE) {        return intersectSphere(ray, geom, hit);    } else if (geom.type == PLANE) {        return intersectPlane(ray, geom, hit);    }    return false; }//---------------------- BACKGROUND COLOR ----------------------// Calcola il colore blu-bianco in base alla coordinata Y del raggiovec4 getSkyColor(Ray ray){	float a = 0.5 * (-ray.direction.y + 1.0); // Inversione	a = pow(a, 2.0); // Funzione esponenziale per rendere la transizione più netta	// Interpolazione del colore blu-bianco	vec3 color = mix(vec3(0.5, 0.7, 1.0), vec3(1.0, 1.0, 1.0), a); // Azzurro a Bianco	return vec4(color, 1.0);}//------------------ RIFLECTION & REFRACTION --------------------//riflection & refraction sono già funzioni di GLSLbool isTotalReflection(Ray ray, GeometryHit hit, float refrIndex, out vec3 refracted) {	 	float cosi = dot(ray.direction, hit.normal);	float etai = 1.0; //uno dei due materiali è sempre l'aria	float etat = refrIndex;	vec3 n = hit.normal;	//notare che mettiamo come indici 1.0 e quello del materiale colpito, poi per sapere se sto passando da aria a materiale o da materiale a aria, verifico sulla base del coseno (eventualmente invertiamo)	if (cosi > 0.0) { //raggio che sta uscendo dal materiale considerato		n = -hit.normal;		float temp = etai;		etai = etat;		etat = temp;	}	float eta = etai / etat;	float k = 1.0 - eta * eta * (1.0 - cosi * cosi);	if (k < 0.0) {		return true; // Total Internal Reflection	}	refracted = eta * ray.direction + (eta * cosi - sqrt(k)) * n;	return false;}//------------------ COLOR CALCULATION ---------------------vec4 rayCasting(Ray ray, uint seed){	vec4 rayColor = vec4(0.0);	vec3 rayAttenuation = vec3(1.0);	for(int bounce = 0; bounce < MAX_DEPTH; bounce++){ // gestione della ricorsione		GeometryHit closestHit;		closestHit.isHit = false;		float closestDist = 1e20;		// troviamo l'oggetto più vicino che viene intersecato		for (int i = 0; i < N_OBJECTS; i++) {			GeometryHit hit;			if (intersectGeometry(ray, geometries[i], hit)) {				float dist = length(hit.position - ray.origin);				if (dist < closestDist) {					closestDist = dist;					closestHit = hit;				}			}		}		if (closestHit.isHit) {			if(closestHit.material.emissionStrength > 0.0) { //se il raggio incontra un materiale che emette luce possiamo uscire dal ciclo				rayColor += vec4(rayAttenuation * closestHit.material.emissionColor.rgb * closestHit.material.emissionStrength, 1.0);				break;			}			float reflectionProb = closestHit.material.smoothness;			float refrIndex = closestHit.material.dieletricConstant;			if (refrIndex > 1.0) { //materiale dielettrico				vec3 refractedDir;				if (isTotalReflection(ray, closestHit, refrIndex, refractedDir)) { //se per caso abbiamo il fenomeno della riflessione totale					ray.direction = reflect(ray.direction, closestHit.normal);				} else {					//decidiamo se il raggio viene riflesso o rifratto 					if (RandomValue(seed) > reflectionProb) { 						ray.direction = reflect(ray.direction, closestHit.normal);					} else {						ray.direction = refractedDir;					}				}			} else {				vec3 specularDir = reflect(ray.direction, closestHit.normal);				vec3 diffuseDir = normalize(closestHit.normal + RandomDirection(randomState));				ray.direction = mix(diffuseDir, specularDir, closestHit.material.smoothness); //linear interpolation tra direzione diffuse e direzione specular			}			ray.origin = closestHit.position + ray.direction * 0.001; //self intersection problem			rayAttenuation *= closestHit.material.color.rgb;		} else {			rayColor += vec4(rayAttenuation, 1.0f) * getSkyColor(ray);			break;		}	}	return rayColor;}vec3 UVtoRayDirection(vec2 uv){	vec2 ndc = uv * 2.0 - 1.0; // Convertiamo le coordinate UV in coordinate NDC (Normalized Device Coordinates), passiamo da un sistema [0,1] a [-1,1]    vec4 clipCoords = vec4(ndc, -1.0, 1.0); // Creiamo un punto nello spazio partendo dalle coordinate di prima, con z = -1    vec4 viewCoords = ubo.invProjectionMatrix * clipCoords; // Convertiamo le coordinate della clip in coordinate dello spazio della vista    vec3 rayDirection = normalize(viewCoords.xyz);  // Normalizziamo le coordinate    return normalize(vec3(ubo.invViewMatrix * vec4(rayDirection, 0.0))); // Trasformiamo la direzione del raggio nello spazio del mondo}void main() {		// Inizializzo seed randomici     uvec2 pixelCoords = uvec2(gl_FragCoord.xy); //PROBABILMENTE QUESTO è DA CAMBIARE........................    uint pixelIndex = pixelCoords.y * 1000 + pixelCoords.x;    randomState = pixelIndex + (uint(gl_FragCoord.w) + gubo.numberOfSamples) * 719393u;    // Creiamo il raggio    Ray ray;    ray.origin = ubo.cameraPos;    ray.direction = UVtoRayDirection(fragUV);		//Definizione materiali	RayTracingMaterial materialLight;	materialLight.color = vec4(0.0, 0.0, 0.0, 0.0);	materialLight.emissionColor = vec4(1.0, 1.0, 1.0, 1.0); 	materialLight.emissionStrength = 1; 	materialLight.smoothness = 0.0;	materialLight.dieletricConstant = NON_DIELECTRIC_REFRACTIVE_INDEX;		RayTracingMaterial material;	material.color = vec4(1.0, 0.0, 1.0, 1.0);	material.emissionColor = vec4(0.0, 0.0, 0.0, 0.0); 	material.emissionStrength = 0.0; 	material.smoothness = 0.0;	material.dieletricConstant = NON_DIELECTRIC_REFRACTIVE_INDEX;			// Definizione di oggetti        geometries[0] = Geometry(SPHERE, materialLight, vec3(1.0f, 4.0f, 2.0f), 3.0f, vec3(0.0), vec3(0.0));    geometries[1] = Geometry(PLANE,  material, vec3(0.0), 0.0f, vec3(0.0, 1.0, 0.0), vec3(0.0f, 1.0f, 0.0f));	geometries[2] = Geometry(SPHERE,  material, vec3(3.0f, 2.0f, 7.0f), 1.0f, vec3(0.0), vec3(0.0));	geometries[2].material.color = vec4(1.0, 1.0, 1.0, 1.0);	geometries[2].material.smoothness = 0.9;	geometries[2].material.dieletricConstant = 1.5; //simuliamo il vetro	geometries[3] = Geometry(SPHERE,  material, vec3(-1.0f, 1.5f, 8.0f), 0.5f, vec3(0.0), vec3(0.0));	geometries[3].material.color = vec4(1.0, 0.0, 0.0, 1.0);			//Per ogni pixel castiamo 100 ray e vediamo se la resolution migliora	vec4 totalLight = vec4(0.0f);	int rayPerPixel = 3;	if(gubo.numberOfSamples == 0){		rayPerPixel = 3; //se vogliamo migliorare la qualità dell'immagine quando ci stiamo muovendo	}	for(int i = 0; i < rayPerPixel; i++){		vec2 jitter = RandomPointInCircle(randomState) * 0.001;		vec2 jitteredUV = fragUV + jitter;				//ray.origin.x = jitteredUV.x;		//ray.origin.y = jitteredUV.y;		ray.direction = UVtoRayDirection(jitteredUV);				totalLight += rayCasting(ray, randomState);	}	totalLight /= rayPerPixel;			//vec3 newColor = pow(totalLight.rgb, vec3(1/2.2)); //gamma correction	vec4 oldColor = vec4(texture(tex, fragUV).rgb, 1.0f);	int N = min(100, gubo.numberOfSamples);	outColor = (oldColor * (N) + totalLight) / (N+1); 		//outColor = (oldColor + totalLight)/2;		/*FADING BIANCO 	vec3 oldColor = texture(tex, fragUV).rgb; 	vec3 newColor = clamp(oldColor + 0.01f, 0.0f, 1.0f);	outColor = vec4(newColor, 1.0f); */			/*	vec3 oldColor = texture(tex, fragUV).rgb;	if(gubo.numberOfSamples < 100){		outColor = totalLight;	}	else{		outColor = vec4(oldColor, 1.0f);	} */}