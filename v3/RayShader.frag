#version 450#extension GL_ARB_separate_shader_objects : enable#define SPHERE 0#define PLANE 1#define MAX_DEPTH 3#define N_OBJECTS 4// Questo definisce la variabile ricevuta dal Vertex Shader// le posizioni devono corrispondere a quelle delle sue variabili outlayout(location = 0) in vec2 fragUV;// Questo definisce il colore calcolato da questo shader. Generalmente è sempre location 0.layout(location = 0) out vec4 outColor;layout(set = 0, binding = 0) uniform GlobalUniformBufferObject {	int numberOfSamples;	int width;	int height;} gubo;	layout(set = 0, binding = 1) uniform sampler2D tex;layout(set = 1, binding = 0) uniform UniformBufferObject {    vec3 cameraPos; // Posizione della camera    mat4 invViewMatrix; // Matrice di vista inversa    mat4 invProjectionMatrix; // Matrice di proiezione inversa} ubo;struct Ray {    vec3 origin;    vec3 direction;};//struct per i materiali, se emetto luce allora emissionColor = bianco e streght > 1, se non emetto colore allora emissionColor = nero e strength = 0struct RayTracingMaterial{	vec4 color; //se il materiale non riflette la luce allora sarà = nero	vec4 emissionColor; //se il materiale è una luce allora avremo emissionColor = bianco, 	float emissionStrength; //potenza della luce	float smoothness; //più uguale a 0, più diffuse material, più 1 più specchio (consiglio, per rendere meglio lo specchio metti il colore = bianco, altrimenti non è molto fedele nei colori riflessi)};struct GeometryHit{ // questa struttura dati contiene le informazioni dell'oggetto che abbiamo colpito col raggio	bool isHit;	vec3 position;	vec3 normal;	RayTracingMaterial material;};// Rendiamo più generico, aggiungiamo la possibilità di inserire nuove figure geometrichestruct Geometry {	//caratteristiche comuni a tutti    int type;	RayTracingMaterial material;	    vec3 center;   // Solo per sfere    float radius;  // Solo per sfere    vec3 point;    // Solo per piani    vec3 normal;   // Solo per piani};// -------------------------- PCG -----------------------------uint randomState;// PCG (permuted congruential generator) www.pcg-random.org uint NextRandom(inout uint state) {	state = state * 747796405 + 2891336453;	uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;	result = (result >> 22) ^ result;	return result;}float RandomValue(inout uint state) {	return NextRandom(state) / 4294967295.0; // 2^32 - 1}// Random value in normal distribution (with mean=0 and sd=1) https://stackoverflow.com/a/6178290float RandomValueNormalDistribution(inout uint state) {	float theta = 2 * 3.1415926 * RandomValue(state);	float rho = sqrt(-2 * log(RandomValue(state)));	return rho * cos(theta);}vec3 RandomDirection(inout uint state) {	float x = RandomValueNormalDistribution(state);	float y = RandomValueNormalDistribution(state);	float z = RandomValueNormalDistribution(state);	return normalize(vec3(x, y, z));}// Genera un punto casuale sul cerchio di raggio 1, usato per il jitteringvec2 RandomPointInCircle(inout uint rngState){	float angle = RandomValue(rngState) * 2 * 3.1415926; //otteniamo un angolo randomico della sfera	vec2 pointOnCircle = vec2(cos(angle), sin(angle)); //trasformiamo l'angolo in coordinate 2D	return pointOnCircle * sqrt(RandomValue(rngState)); //otteniamo un punto qualsiasi lungo il raggio che collega il centro al punto 2D}// ------------------- RAY INTERSECTION METHODS --------------------- Geometry geometries[N_OBJECTS];// Funzione per calcolare l'intersezione tra un raggio e una sferabool intersectSphere(Ray ray, Geometry geom, out GeometryHit hit) {    vec3 oc = ray.origin - geom.center; // distanza tra i due centri	    // coefficienti della formula quadratica per l'intersezione di un raggio con una sfera    float a = dot(ray.direction, ray.direction); // a = 1    float b = 2.0 * dot(oc, ray.direction);    float c = dot(oc, oc) - geom.radius * geom.radius;    float discriminant = b * b - 4.0 * a * c;    if (discriminant > 0.0) {        // poiché è un'equazione quadratica abbiamo due possibili soluzioni, quindi dobbiamo prendere la più vicina        float dst = (-b - sqrt(discriminant)) / (2.0 * a);        if (dst > 0.0) {            hit.position = ray.origin + dst * ray.direction;			hit.normal = normalize(hit.position - geom.center);			hit.material = geom.material;			hit.isHit = true;            return true;        }    }    return false;}bool intersectPlane(Ray ray, Geometry geom, out GeometryHit hit) {    float denom = dot(geom.normal, ray.direction);     if (abs(denom) < 0.0001f) { //verifichiamo che il raggio non sia parallelo al piano        return false;     }    vec3 rayPlane = geom.point - ray.origin; // Vettore dal punto del raggio al punto del piano    float t = dot(rayPlane, geom.normal) / denom; // distanza      if (t < 0) { // Se t è negativo, l'intersezione è dietro il raggio        return false;     }    hit.position = ray.origin + t * ray.direction; 	hit.normal = geom.normal;	hit.material = geom.material;	hit.isHit = true;    return true;}// Scegliamo il metodo di calcolo dell'intersezione sulla base della tipologia di geometriabool intersectGeometry(Ray ray, Geometry geom, inout GeometryHit hit) {    if (geom.type == SPHERE) {        return intersectSphere(ray, geom, hit);    } else if (geom.type == PLANE) {        return intersectPlane(ray, geom, hit);    }    return false; }//---------------------- BACKGROUND COLOR ----------------------// Calcola il colore blu-bianco in base alla coordinata Y del raggiovec4 getSkyColor(Ray ray){	float a = 0.5 * (-ray.direction.y + 1.0); // Inversione	a = pow(a, 2.0); // Funzione esponenziale per rendere la transizione più netta	// Interpolazione del colore blu-bianco	vec3 color = mix(vec3(0.5, 0.7, 1.0), vec3(1.0, 1.0, 1.0), a); // Azzurro a Bianco	return vec4(color, 1.0);}// Cast del rayGeometryHit rayCast(Ray ray){	// Punto di intersezione	float closestDst = 100.0;	GeometryHit bestHit;	bestHit.isHit = false;		// Controlla chi andiamo a intersecare con il nostro ray 	for(int i = 0; i < N_OBJECTS; i++){		GeometryHit possibleHit;		if(intersectGeometry(ray, geometries[i], possibleHit)){			float dst = length(possibleHit.position - ray.origin);			if(dst < closestDst){				closestDst = dst;				bestHit = possibleHit;			}		}	}		return bestHit;}vec4 recursionRay(Ray ray){	vec4 incomingLight = vec4(0.0f, 0.0f, 0.0f, 0.0f);	vec4 color = vec4(1.0f, 1.0f, 1.0f, 1.0f); //colore base bianco, più rimbalza il raggio e più diventa scuro		for(int i = 0; i < MAX_DEPTH; i++){			GeometryHit hit = rayCast(ray);		if(hit.isHit){ // abbiamo intersecato qualcosa quindi bisogna castare un nuovo raggio			ray.origin = hit.position + hit.normal * 0.0001f; //self intersection problem						vec3 diffuseDirection = normalize(hit.normal + RandomDirection(randomState));			vec3 specularDirection = ray.direction - 2 * dot(ray.direction, hit.normal) * hit.normal;			ray.direction = mix(diffuseDirection, specularDirection, hit.material.smoothness);						RayTracingMaterial material = hit.material;			vec4 emittedLight = material.emissionColor * material.emissionStrength;			incomingLight += emittedLight * color;			color *= material.color;		}		else{			//incomingLight += getSkyColor(ray) * color;			break;		}		}		return incomingLight;	}vec3 UVtoRayDirection(vec2 uv){	vec2 ndc = uv * 2.0 - 1.0; // Convertiamo le coordinate UV in coordinate NDC (Normalized Device Coordinates), passiamo da un sistema [0,1] a [-1,1]    vec4 clipCoords = vec4(ndc, -1.0, 1.0); // Creiamo un punto nello spazio partendo dalle coordinate di prima, con z = -1    vec4 viewCoords = ubo.invProjectionMatrix * clipCoords; // Convertiamo le coordinate della clip in coordinate dello spazio della vista    vec3 rayDirection = normalize(viewCoords.xyz);  // Normalizziamo le coordinate    return normalize(vec3(ubo.invViewMatrix * vec4(rayDirection, 0.0))); // Trasformiamo la direzione del raggio nello spazio del mondo}void main() {		// Inizializzo seed randomici     uvec2 pixelCoords = uvec2(gl_FragCoord.xy); //PROBABILMENTE QUESTO è DA CAMBIARE........................    uint pixelIndex = pixelCoords.y * 1000 + pixelCoords.x;    randomState = pixelIndex + (uint(gl_FragCoord.w) + gubo.numberOfSamples) * 719393u;    // Creiamo il raggio    Ray ray;    ray.origin = ubo.cameraPos;    ray.direction = UVtoRayDirection(fragUV);		//Definizione materiali	RayTracingMaterial materialLight;	materialLight.color = vec4(0.0, 0.0, 0.0, 0.0);	materialLight.emissionColor = vec4(1.0, 1.0, 1.0, 1.0); 	materialLight.emissionStrength = 1; 	materialLight.smoothness = 0.0;		RayTracingMaterial material;	material.color = vec4(1.0, 0.0, 1.0, 1.0);	material.emissionColor = vec4(0.0, 0.0, 0.0, 0.0); 	material.emissionStrength = 0.0; 	material.smoothness = 0.0;			// Definizione di oggetti        geometries[0] = Geometry(SPHERE, materialLight, vec3(1.0f, 4.0f, 2.0f), 3.0f, vec3(0.0), vec3(0.0));    geometries[1] = Geometry(PLANE,  material, vec3(0.0), 0.0f, vec3(0.0, 1.0, 0.0), vec3(0.0f, 1.0f, 0.0f));	geometries[2] = Geometry(SPHERE,  material, vec3(3.0f, 2.0f, 7.0f), 1.0f, vec3(0.0), vec3(0.0));	geometries[2].material.color = vec4(1.0, 1.0, 1.0, 1.0);	geometries[2].material.smoothness = 1.0;	geometries[3] = Geometry(SPHERE,  material, vec3(-1.0f, 1.5f, 8.0f), 0.5f, vec3(0.0), vec3(0.0));	geometries[3].material.color = vec4(1.0, 0.0, 0.0, 1.0);			//Per ogni pixel castiamo 100 ray e vediamo se la resolution migliora	vec4 totalLight = vec4(0.0f);	int rayPerPixel = 3;	if(gubo.numberOfSamples == 0){		rayPerPixel = 3; //se vogliamo migliorare la qualità dell'immagine quando ci stiamo muovendo	}	for(int i = 0; i < rayPerPixel; i++){		vec2 jitter = RandomPointInCircle(randomState) * 0.001;		vec2 jitteredUV = fragUV + jitter;				//ray.origin.x = jitteredUV.x;		//ray.origin.y = jitteredUV.y;		ray.direction = UVtoRayDirection(jitteredUV);				totalLight += recursionRay(ray);	}	totalLight /= rayPerPixel;			//vec3 newColor = pow(totalLight.rgb, vec3(1/2.2)); //gamma correction	vec4 oldColor = vec4(texture(tex, fragUV).rgb, 1.0f);	int N = min(10, gubo.numberOfSamples);	outColor = (oldColor * (N) + totalLight) / (N+1); 		//outColor = (oldColor + totalLight)/2;		/*FADING BIANCO 	vec3 oldColor = texture(tex, fragUV).rgb; 	vec3 newColor = clamp(oldColor + 0.01f, 0.0f, 1.0f);	outColor = vec4(newColor, 1.0f); */			/*	vec3 oldColor = texture(tex, fragUV).rgb;	if(gubo.numberOfSamples < 100){		outColor = totalLight;	}	else{		outColor = vec4(oldColor, 1.0f);	} */}